From fa48a06ca870313767978cfda703db6473cda8c2 Mon Sep 17 00:00:00 2001
From: Matthias Runge <mrunge@redhat.com>
Date: Wed, 5 Dec 2018 14:10:02 +0100
Subject: [PATCH 55/55] Backport bonded devices plus add'l stats

---
 src/ovs_stats.c | 1047 +++++++++++++++++++++++++++++++++--------------
 1 file changed, 736 insertions(+), 311 deletions(-)

diff --git a/src/ovs_stats.c b/src/ovs_stats.c
index e027845e..9e92ae37 100644
--- a/src/ovs_stats.c
+++ b/src/ovs_stats.c
@@ -63,6 +63,7 @@ typedef enum iface_counter {
   tx_512_to_1023_packets,
   tx_1024_to_1522_packets,
   tx_1523_to_max_packets,
+  rx_multicast_packets,
   tx_multicast_packets,
   rx_broadcast_packets,
   tx_broadcast_packets,
@@ -70,6 +71,21 @@ typedef enum iface_counter {
   rx_oversize_errors,
   rx_fragmented_errors,
   rx_jabber_errors,
+  rx_error_bytes,
+  rx_l3_l4_xsum_error,
+  rx_management_dropped,
+  rx_mbuf_allocation_errors,
+  rx_total_bytes,
+  rx_total_missed_packets,
+  rx_undersize_errors,
+  rx_management_packets,
+  tx_management_packets,
+  rx_good_bytes,
+  tx_good_bytes,
+  rx_good_packets,
+  tx_good_packets,
+  rx_total_packets,
+  tx_total_packets,
   __iface_counter_max
 } iface_counter;
 
@@ -78,15 +94,21 @@ typedef enum iface_counter {
 #define PORT_NAME_SIZE_MAX 255
 #define UUID_SIZE 64
 
-typedef struct port_s {
-  char name[PORT_NAME_SIZE_MAX];      /* Port name */
-  char port_uuid[UUID_SIZE];          /* Port table _uuid */
+typedef struct interface_s {
+  char name[PORT_NAME_SIZE_MAX];      /* Interface name */
   char iface_uuid[UUID_SIZE];         /* Interface table uuid */
   char ex_iface_id[UUID_SIZE];        /* External iface id */
   char ex_vm_id[UUID_SIZE];           /* External vm id */
-  int64_t stats[IFACE_COUNTER_COUNT]; /* Port statistics */
-  struct bridge_list_s *br;           /* Pointer to bridge */
-  struct port_s *next;                /* Next port */
+  int64_t stats[IFACE_COUNTER_COUNT]; /* Statistics for interface */
+  struct interface_s *next;           /* Next interface for associated port */
+} interface_list_t;
+
+typedef struct port_s {
+  char name[PORT_NAME_SIZE_MAX]; /* Port name */
+  char port_uuid[UUID_SIZE];     /* Port table _uuid */
+  struct bridge_list_s *br;      /* Pointer to bridge */
+  struct interface_s *iface;     /* Pointer to first interface */
+  struct port_s *next;           /* Next port */
 } port_list_t;
 
 typedef struct bridge_list_s {
@@ -94,42 +116,62 @@ typedef struct bridge_list_s {
   struct bridge_list_s *next; /* Next bridge*/
 } bridge_list_t;
 
+#define cnt_str(x) [x] = #x
+
 static const char *const iface_counter_table[IFACE_COUNTER_COUNT] = {
-        [collisions] = "collisions",
-        [rx_bytes] = "rx_bytes",
-        [rx_crc_err] = "rx_crc_err",
-        [rx_dropped] = "rx_dropped",
-        [rx_errors] = "rx_errors",
-        [rx_frame_err] = "rx_frame_err",
-        [rx_over_err] = "rx_over_err",
-        [rx_packets] = "rx_packets",
-        [tx_bytes] = "tx_bytes",
-        [tx_dropped] = "tx_dropped",
-        [tx_errors] = "tx_errors",
-        [tx_packets] = "tx_packets",
-        [rx_1_to_64_packets] = "rx_1_to_64_packets",
-        [rx_65_to_127_packets] = "rx_65_to_127_packets",
-        [rx_128_to_255_packets] = "rx_128_to_255_packets",
-        [rx_256_to_511_packets] = "rx_256_to_511_packets",
-        [rx_512_to_1023_packets] = "rx_512_to_1023_packets",
-        [rx_1024_to_1522_packets] = "rx_1024_to_1518_packets",
-        [rx_1523_to_max_packets] = "rx_1523_to_max_packets",
-        [tx_1_to_64_packets] = "tx_1_to_64_packets",
-        [tx_65_to_127_packets] = "tx_65_to_127_packets",
-        [tx_128_to_255_packets] = "tx_128_to_255_packets",
-        [tx_256_to_511_packets] = "tx_256_to_511_packets",
-        [tx_512_to_1023_packets] = "tx_512_to_1023_packets",
-        [tx_1024_to_1522_packets] = "tx_1024_to_1518_packets",
-        [tx_1523_to_max_packets] = "tx_1523_to_max_packets",
-        [tx_multicast_packets] = "tx_multicast_packets",
-        [rx_broadcast_packets] = "rx_broadcast_packets",
-        [tx_broadcast_packets] = "tx_broadcast_packets",
-        [rx_undersized_errors] = "rx_undersized_errors",
-        [rx_oversize_errors] = "rx_oversize_errors",
-        [rx_fragmented_errors] = "rx_fragmented_errors",
-        [rx_jabber_errors] = "rx_jabber_errors",
+    cnt_str(collisions),
+    cnt_str(rx_bytes),
+    cnt_str(rx_crc_err),
+    cnt_str(rx_dropped),
+    cnt_str(rx_errors),
+    cnt_str(rx_frame_err),
+    cnt_str(rx_over_err),
+    cnt_str(rx_packets),
+    cnt_str(tx_bytes),
+    cnt_str(tx_dropped),
+    cnt_str(tx_errors),
+    cnt_str(tx_packets),
+    cnt_str(rx_1_to_64_packets),
+    cnt_str(rx_65_to_127_packets),
+    cnt_str(rx_128_to_255_packets),
+    cnt_str(rx_256_to_511_packets),
+    cnt_str(rx_512_to_1023_packets),
+    cnt_str(rx_1024_to_1522_packets),
+    cnt_str(rx_1523_to_max_packets),
+    cnt_str(tx_1_to_64_packets),
+    cnt_str(tx_65_to_127_packets),
+    cnt_str(tx_128_to_255_packets),
+    cnt_str(tx_256_to_511_packets),
+    cnt_str(tx_512_to_1023_packets),
+    cnt_str(tx_1024_to_1522_packets),
+    cnt_str(tx_1523_to_max_packets),
+    cnt_str(rx_multicast_packets),
+    cnt_str(tx_multicast_packets),
+    cnt_str(rx_broadcast_packets),
+    cnt_str(tx_broadcast_packets),
+    cnt_str(rx_undersized_errors),
+    cnt_str(rx_oversize_errors),
+    cnt_str(rx_fragmented_errors),
+    cnt_str(rx_jabber_errors),
+    cnt_str(rx_error_bytes),
+    cnt_str(rx_l3_l4_xsum_error),
+    cnt_str(rx_management_dropped),
+    cnt_str(rx_mbuf_allocation_errors),
+    cnt_str(rx_total_bytes),
+    cnt_str(rx_total_missed_packets),
+    cnt_str(rx_undersize_errors),
+    cnt_str(rx_management_packets),
+    cnt_str(tx_management_packets),
+    cnt_str(rx_good_bytes),
+    cnt_str(tx_good_bytes),
+    cnt_str(rx_good_packets),
+    cnt_str(tx_good_packets),
+    cnt_str(rx_total_packets),
+    cnt_str(tx_total_packets),
 };
 
+#undef cnt_str
+
 /* Entry into the list of network bridges */
 static bridge_list_t *g_bridge_list_head;
 
@@ -158,6 +200,9 @@ static ovs_stats_config_t ovs_stats_cfg = {
     .ovs_db_serv = "6640",      /* use default OVS DB service */
 };
 
+/* flag indicating whether or not to publish individual interface statistics */
+static _Bool interface_stats = 0;
+
 static iface_counter ovs_stats_counter_name_to_type(const char *counter) {
   iface_counter index = not_supported;
 
@@ -219,6 +264,261 @@ static void ovs_stats_submit_two(const char *dev, const char *type,
   plugin_dispatch_values(&vl);
 }
 
+static void ovs_stats_submit_interfaces(port_list_t *port) {
+  char devname[PORT_NAME_SIZE_MAX * 2];
+
+  bridge_list_t *bridge = port->br;
+  for (interface_list_t *iface = port->iface; iface != NULL;
+       iface = iface->next) {
+    meta_data_t *meta = meta_data_create();
+    if (meta != NULL) {
+      meta_data_add_string(meta, "uuid", iface->iface_uuid);
+
+      if (strlen(iface->ex_vm_id))
+        meta_data_add_string(meta, "vm-uuid", iface->ex_vm_id);
+
+      if (strlen(iface->ex_iface_id))
+        meta_data_add_string(meta, "iface-id", iface->ex_iface_id);
+    }
+    snprintf(devname, sizeof(devname), "%s.%s.%s", bridge->name, port->name,
+             iface->name);
+    ovs_stats_submit_one(devname, "if_collisions", NULL,
+                         iface->stats[collisions], meta);
+    ovs_stats_submit_two(devname, "if_dropped", NULL, iface->stats[rx_dropped],
+                         iface->stats[tx_dropped], meta);
+    ovs_stats_submit_two(devname, "if_errors", NULL, iface->stats[rx_errors],
+                         iface->stats[tx_errors], meta);
+    ovs_stats_submit_two(devname, "if_packets", NULL, iface->stats[rx_packets],
+                         iface->stats[tx_packets], meta);
+    ovs_stats_submit_one(devname, "if_rx_errors", "crc",
+                         iface->stats[rx_crc_err], meta);
+    ovs_stats_submit_one(devname, "if_rx_errors", "frame",
+                         iface->stats[rx_frame_err], meta);
+    ovs_stats_submit_one(devname, "if_rx_errors", "over",
+                         iface->stats[rx_over_err], meta);
+    ovs_stats_submit_one(devname, "if_rx_octets", NULL, iface->stats[rx_bytes],
+                         meta);
+    ovs_stats_submit_one(devname, "if_tx_octets", NULL, iface->stats[tx_bytes],
+                         meta);
+    ovs_stats_submit_two(devname, "if_packets", "1_to_64_packets",
+                         iface->stats[rx_1_to_64_packets],
+                         iface->stats[tx_1_to_64_packets], meta);
+    ovs_stats_submit_two(devname, "if_packets", "65_to_127_packets",
+                         iface->stats[rx_65_to_127_packets],
+                         iface->stats[tx_65_to_127_packets], meta);
+    ovs_stats_submit_two(devname, "if_packets", "128_to_255_packets",
+                         iface->stats[rx_128_to_255_packets],
+                         iface->stats[tx_128_to_255_packets], meta);
+    ovs_stats_submit_two(devname, "if_packets", "256_to_511_packets",
+                         iface->stats[rx_256_to_511_packets],
+                         iface->stats[tx_256_to_511_packets], meta);
+    ovs_stats_submit_two(devname, "if_packets", "512_to_1023_packets",
+                         iface->stats[rx_512_to_1023_packets],
+                         iface->stats[tx_512_to_1023_packets], meta);
+    ovs_stats_submit_two(devname, "if_packets", "1024_to_1522_packets",
+                         iface->stats[rx_1024_to_1522_packets],
+                         iface->stats[tx_1024_to_1522_packets], meta);
+    ovs_stats_submit_two(devname, "if_packets", "1523_to_max_packets",
+                         iface->stats[rx_1523_to_max_packets],
+                         iface->stats[tx_1523_to_max_packets], meta);
+    ovs_stats_submit_two(devname, "if_packets", "broadcast_packets",
+                         iface->stats[rx_broadcast_packets],
+                         iface->stats[tx_broadcast_packets], meta);
+    ovs_stats_submit_one(devname, "if_rx_errors", "rx_undersized_errors",
+                         iface->stats[rx_undersized_errors], meta);
+    ovs_stats_submit_one(devname, "if_rx_errors", "rx_oversize_errors",
+                         iface->stats[rx_oversize_errors], meta);
+    ovs_stats_submit_one(devname, "if_rx_errors", "rx_fragmented_errors",
+                         iface->stats[rx_fragmented_errors], meta);
+    ovs_stats_submit_one(devname, "if_rx_errors", "rx_jabber_errors",
+                         iface->stats[rx_jabber_errors], meta);
+    ovs_stats_submit_one(devname, "if_rx_octets", "rx_error_bytes",
+                         iface->stats[rx_error_bytes], meta);
+    ovs_stats_submit_one(devname, "if_errors", "rx_l3_l4_xsum_error",
+                         iface->stats[rx_l3_l4_xsum_error], meta);
+    ovs_stats_submit_one(devname, "if_dropped", "rx_management_dropped",
+                         iface->stats[rx_management_dropped], meta);
+    ovs_stats_submit_one(devname, "if_errors", "rx_mbuf_allocation_errors",
+                         iface->stats[rx_mbuf_allocation_errors], meta);
+    ovs_stats_submit_one(devname, "if_octets", "rx_total_bytes",
+                         iface->stats[rx_total_bytes], meta);
+    ovs_stats_submit_one(devname, "if_packets", "rx_total_missed_packets",
+                         iface->stats[rx_total_missed_packets], meta);
+    ovs_stats_submit_one(devname, "if_rx_errors", "rx_undersize_errors",
+                         iface->stats[rx_undersize_errors], meta);
+    ovs_stats_submit_two(devname, "if_packets", "management_packets",
+                         iface->stats[rx_management_packets],
+                         iface->stats[tx_management_packets], meta);
+    ovs_stats_submit_two(devname, "if_packets", "multicast_packets",
+                         iface->stats[rx_multicast_packets],
+                         iface->stats[tx_multicast_packets], meta);
+    ovs_stats_submit_two(devname, "if_octets", "good_bytes",
+                         iface->stats[rx_good_bytes],
+                         iface->stats[tx_good_bytes], meta);
+    ovs_stats_submit_two(devname, "if_packets", "good_packets",
+                         iface->stats[rx_good_packets],
+                         iface->stats[tx_good_packets], meta);
+    ovs_stats_submit_two(devname, "if_packets", "total_packets",
+                         iface->stats[rx_total_packets],
+                         iface->stats[tx_total_packets], meta);
+
+    meta_data_destroy(meta);
+  }
+}
+
+static int ovs_stats_get_port_stat_value(port_list_t *port,
+                                         iface_counter index) {
+  if (port == NULL)
+    return 0;
+
+  int value = 0;
+
+  for (interface_list_t *iface = port->iface; iface != NULL;
+       iface = iface->next) {
+    value = value + iface->stats[index];
+  }
+
+  return value;
+}
+
+static void ovs_stats_submit_port(port_list_t *port) {
+  char devname[PORT_NAME_SIZE_MAX * 2];
+
+  meta_data_t *meta = meta_data_create();
+  if (meta != NULL) {
+    char key_str[DATA_MAX_NAME_LEN];
+    int i = 0;
+
+    for (interface_list_t *iface = port->iface; iface != NULL;
+         iface = iface->next) {
+      snprintf(key_str, sizeof(key_str), "uuid%d", i);
+      meta_data_add_string(meta, key_str, iface->iface_uuid);
+
+      if (strlen(iface->ex_vm_id)) {
+        snprintf(key_str, sizeof(key_str), "vm-uuid%d", i);
+        meta_data_add_string(meta, key_str, iface->ex_vm_id);
+      }
+
+      if (strlen(iface->ex_iface_id)) {
+        snprintf(key_str, sizeof(key_str), "iface-id%d", i);
+        meta_data_add_string(meta, key_str, iface->ex_iface_id);
+      }
+
+      i++;
+    }
+  }
+  bridge_list_t *bridge = port->br;
+  snprintf(devname, sizeof(devname), "%s.%s", bridge->name, port->name);
+  ovs_stats_submit_one(devname, "if_collisions", NULL,
+                       ovs_stats_get_port_stat_value(port, collisions), meta);
+  ovs_stats_submit_two(devname, "if_dropped", NULL,
+                       ovs_stats_get_port_stat_value(port, rx_dropped),
+                       ovs_stats_get_port_stat_value(port, tx_dropped), meta);
+  ovs_stats_submit_two(devname, "if_errors", NULL,
+                       ovs_stats_get_port_stat_value(port, rx_errors),
+                       ovs_stats_get_port_stat_value(port, tx_errors), meta);
+  ovs_stats_submit_two(devname, "if_packets", NULL,
+                       ovs_stats_get_port_stat_value(port, rx_packets),
+                       ovs_stats_get_port_stat_value(port, tx_packets), meta);
+  ovs_stats_submit_one(devname, "if_rx_errors", "crc",
+                       ovs_stats_get_port_stat_value(port, rx_crc_err), meta);
+  ovs_stats_submit_one(devname, "if_rx_errors", "frame",
+                       ovs_stats_get_port_stat_value(port, rx_frame_err), meta);
+  ovs_stats_submit_one(devname, "if_rx_errors", "over",
+                       ovs_stats_get_port_stat_value(port, rx_over_err), meta);
+  ovs_stats_submit_one(devname, "if_rx_octets", NULL,
+                       ovs_stats_get_port_stat_value(port, rx_bytes), meta);
+  ovs_stats_submit_one(devname, "if_tx_octets", NULL,
+                       ovs_stats_get_port_stat_value(port, tx_bytes), meta);
+  ovs_stats_submit_two(devname, "if_packets", "1_to_64_packets",
+                       ovs_stats_get_port_stat_value(port, rx_1_to_64_packets),
+                       ovs_stats_get_port_stat_value(port, tx_1_to_64_packets),
+                       meta);
+  ovs_stats_submit_two(
+      devname, "if_packets", "65_to_127_packets",
+      ovs_stats_get_port_stat_value(port, rx_65_to_127_packets),
+      ovs_stats_get_port_stat_value(port, tx_65_to_127_packets), meta);
+  ovs_stats_submit_two(
+      devname, "if_packets", "128_to_255_packets",
+      ovs_stats_get_port_stat_value(port, rx_128_to_255_packets),
+      ovs_stats_get_port_stat_value(port, tx_128_to_255_packets), meta);
+  ovs_stats_submit_two(
+      devname, "if_packets", "256_to_511_packets",
+      ovs_stats_get_port_stat_value(port, rx_256_to_511_packets),
+      ovs_stats_get_port_stat_value(port, tx_256_to_511_packets), meta);
+  ovs_stats_submit_two(
+      devname, "if_packets", "512_to_1023_packets",
+      ovs_stats_get_port_stat_value(port, rx_512_to_1023_packets),
+      ovs_stats_get_port_stat_value(port, tx_512_to_1023_packets), meta);
+  ovs_stats_submit_two(
+      devname, "if_packets", "1024_to_1522_packets",
+      ovs_stats_get_port_stat_value(port, rx_1024_to_1522_packets),
+      ovs_stats_get_port_stat_value(port, tx_1024_to_1522_packets), meta);
+  ovs_stats_submit_two(
+      devname, "if_packets", "1523_to_max_packets",
+      ovs_stats_get_port_stat_value(port, rx_1523_to_max_packets),
+      ovs_stats_get_port_stat_value(port, tx_1523_to_max_packets), meta);
+  ovs_stats_submit_two(
+      devname, "if_packets", "broadcast_packets",
+      ovs_stats_get_port_stat_value(port, rx_broadcast_packets),
+      ovs_stats_get_port_stat_value(port, tx_broadcast_packets), meta);
+  ovs_stats_submit_one(
+      devname, "if_rx_errors", "rx_undersized_errors",
+      ovs_stats_get_port_stat_value(port, rx_undersized_errors), meta);
+  ovs_stats_submit_one(devname, "if_rx_errors", "rx_oversize_errors",
+                       ovs_stats_get_port_stat_value(port, rx_oversize_errors),
+                       meta);
+  ovs_stats_submit_one(
+      devname, "if_rx_errors", "rx_fragmented_errors",
+      ovs_stats_get_port_stat_value(port, rx_fragmented_errors), meta);
+  ovs_stats_submit_one(devname, "if_rx_errors", "rx_jabber_errors",
+                       ovs_stats_get_port_stat_value(port, rx_jabber_errors),
+                       meta);
+  ovs_stats_submit_one(devname, "if_rx_octets", "rx_error_bytes",
+                       ovs_stats_get_port_stat_value(port, rx_error_bytes),
+                       meta);
+  ovs_stats_submit_one(devname, "if_errors", "rx_l3_l4_xsum_error",
+                       ovs_stats_get_port_stat_value(port, rx_l3_l4_xsum_error),
+                       meta);
+  ovs_stats_submit_one(
+      devname, "if_dropped", "rx_management_dropped",
+      ovs_stats_get_port_stat_value(port, rx_management_dropped), meta);
+  ovs_stats_submit_one(
+      devname, "if_errors", "rx_mbuf_allocation_errors",
+      ovs_stats_get_port_stat_value(port, rx_mbuf_allocation_errors), meta);
+  ovs_stats_submit_one(devname, "if_octets", "rx_total_bytes",
+                       ovs_stats_get_port_stat_value(port, rx_total_bytes),
+                       meta);
+  ovs_stats_submit_one(
+      devname, "if_packets", "rx_total_missed_packets",
+      ovs_stats_get_port_stat_value(port, rx_total_missed_packets), meta);
+  ovs_stats_submit_one(devname, "if_rx_errors", "rx_undersize_errors",
+                       ovs_stats_get_port_stat_value(port, rx_undersize_errors),
+                       meta);
+  ovs_stats_submit_two(
+      devname, "if_packets", "management_packets",
+      ovs_stats_get_port_stat_value(port, rx_management_packets),
+      ovs_stats_get_port_stat_value(port, tx_management_packets), meta);
+  ovs_stats_submit_two(
+      devname, "if_packets", "multicast_packets",
+      ovs_stats_get_port_stat_value(port, rx_multicast_packets),
+      ovs_stats_get_port_stat_value(port, tx_multicast_packets), meta);
+  ovs_stats_submit_two(devname, "if_octets", "good_bytes",
+                       ovs_stats_get_port_stat_value(port, rx_good_bytes),
+                       ovs_stats_get_port_stat_value(port, tx_good_bytes),
+                       meta);
+  ovs_stats_submit_two(devname, "if_packets", "good_packets",
+                       ovs_stats_get_port_stat_value(port, rx_good_packets),
+                       ovs_stats_get_port_stat_value(port, tx_good_packets),
+                       meta);
+  ovs_stats_submit_two(devname, "if_packets", "total_packets",
+                       ovs_stats_get_port_stat_value(port, rx_total_packets),
+                       ovs_stats_get_port_stat_value(port, tx_total_packets),
+                       meta);
+
+  meta_data_destroy(meta);
+}
+
 static port_list_t *ovs_stats_get_port(const char *uuid) {
   if (uuid == NULL)
     return NULL;
@@ -230,20 +530,75 @@ static port_list_t *ovs_stats_get_port(const char *uuid) {
   return NULL;
 }
 
-static port_list_t *ovs_stats_get_port_by_name(const char *name) {
-  if (name == NULL)
+static port_list_t *ovs_stats_get_port_by_interface_uuid(const char *uuid) {
+  if (uuid == NULL)
     return NULL;
 
-  for (port_list_t *port = g_port_list_head; port != NULL; port = port->next)
-    if ((strncmp(port->name, name, strlen(port->name)) == 0) &&
-        strlen(name) == strlen(port->name))
-      return port;
+  for (port_list_t *port = g_port_list_head; port != NULL; port = port->next) {
+    for (interface_list_t *iface = port->iface; iface != NULL;
+         iface = iface->next) {
+      if (strncmp(iface->iface_uuid, uuid, strlen(uuid)) == 0)
+        return port;
+    }
+  }
+  return NULL;
+}
+
+static interface_list_t *ovs_stats_get_port_interface(port_list_t *port,
+                                                      const char *uuid) {
+  if (port == NULL || uuid == NULL)
+    return NULL;
+
+  for (interface_list_t *iface = port->iface; iface != NULL;
+       iface = iface->next) {
+    if (strncmp(iface->iface_uuid, uuid, strlen(uuid)) == 0)
+      return iface;
+  }
+  return NULL;
+}
+
+static interface_list_t *ovs_stats_get_interface(const char *uuid) {
+  if (uuid == NULL)
+    return NULL;
+
+  for (port_list_t *port = g_port_list_head; port != NULL; port = port->next) {
+    for (interface_list_t *iface = port->iface; iface != NULL;
+         iface = iface->next) {
+      if (strncmp(iface->iface_uuid, uuid, strlen(uuid)) == 0)
+        return iface;
+    }
+  }
   return NULL;
 }
 
+static interface_list_t *ovs_stats_new_port_interface(port_list_t *port,
+                                                      const char *uuid) {
+  if (uuid == NULL)
+    return NULL;
+
+  interface_list_t *iface = ovs_stats_get_port_interface(port, uuid);
+
+  if (iface == NULL) {
+    iface = (interface_list_t *)calloc(1, sizeof(interface_list_t));
+    if (!iface) {
+      ERROR("%s: Error allocating interface", plugin_name);
+      return NULL;
+    }
+    memset(iface->stats, -1, sizeof(int64_t[IFACE_COUNTER_COUNT]));
+    sstrncpy(iface->iface_uuid, uuid, sizeof(iface->iface_uuid));
+    interface_list_t *iface_head = port->iface;
+    iface->next = iface_head;
+    port->iface = iface;
+  }
+  return iface;
+}
+
 /* Create or get port by port uuid */
 static port_list_t *ovs_stats_new_port(bridge_list_t *bridge,
                                        const char *uuid) {
+  if (uuid == NULL)
+    return NULL;
+
   port_list_t *port = ovs_stats_get_port(uuid);
 
   if (port == NULL) {
@@ -252,17 +607,12 @@ static port_list_t *ovs_stats_new_port(bridge_list_t *bridge,
       ERROR("%s: Error allocating port", plugin_name);
       return NULL;
     }
-    memset(port->stats, -1, sizeof(int64_t[IFACE_COUNTER_COUNT]));
     sstrncpy(port->port_uuid, uuid, sizeof(port->port_uuid));
-    pthread_mutex_lock(&g_stats_lock);
     port->next = g_port_list_head;
     g_port_list_head = port;
-    pthread_mutex_unlock(&g_stats_lock);
   }
   if (bridge != NULL) {
-    pthread_mutex_lock(&g_stats_lock);
     port->br = bridge;
-    pthread_mutex_unlock(&g_stats_lock);
   }
   return port;
 }
@@ -281,36 +631,51 @@ static bridge_list_t *ovs_stats_get_bridge(bridge_list_t *head,
   return NULL;
 }
 
+/* Check if bridge is configured to be monitored in config file */
+static int ovs_stats_is_monitored_bridge(const char *br_name) {
+  /* if no bridges are configured, return true */
+  if (g_monitored_bridge_list_head == NULL)
+    return 1;
+
+  /* check if given bridge exists */
+  if (ovs_stats_get_bridge(g_monitored_bridge_list_head, br_name) != NULL)
+    return 1;
+
+  return 0;
+}
+
 /* Delete bridge */
 static int ovs_stats_del_bridge(yajl_val bridge) {
   const char *old[] = {"old", NULL};
   const char *name[] = {"name", NULL};
 
-  yajl_val row;
-
-  if (bridge && YAJL_IS_OBJECT(bridge)) {
-    row = yajl_tree_get(bridge, old, yajl_t_object);
-    if (row && YAJL_IS_OBJECT(row)) {
-      yajl_val br_name = yajl_tree_get(row, name, yajl_t_string);
-      if (br_name && YAJL_IS_STRING(br_name)) {
-        bridge_list_t *prev_br = g_bridge_list_head;
-        for (bridge_list_t *br = g_bridge_list_head; br != NULL;
-             prev_br = br, br = br->next) {
-          if ((strncmp(br->name, br_name->u.string, strlen(br->name)) == 0) &&
-              strlen(br->name) == strlen(br_name->u.string)) {
-            if (br == g_bridge_list_head)
-              g_bridge_list_head = br->next;
-            else
-              prev_br->next = br->next;
-            sfree(br->name);
-            sfree(br);
-            break;
-          }
-        }
-      }
-    }
-  } else
+  if (!bridge || !YAJL_IS_OBJECT(bridge)) {
     WARNING("%s: Incorrect data for deleting bridge", plugin_name);
+    return 0;
+  }
+
+  yajl_val row = yajl_tree_get(bridge, old, yajl_t_object);
+  if (!row || !YAJL_IS_OBJECT(row))
+    return 0;
+
+  yajl_val br_name = yajl_tree_get(row, name, yajl_t_string);
+  if (!br_name || !YAJL_IS_STRING(br_name))
+    return 0;
+
+  bridge_list_t *prev_br = g_bridge_list_head;
+  for (bridge_list_t *br = g_bridge_list_head; br != NULL;
+       prev_br = br, br = br->next) {
+    if ((strncmp(br->name, br_name->u.string, strlen(br->name)) == 0) &&
+        strlen(br->name) == strlen(br_name->u.string)) {
+      if (br == g_bridge_list_head)
+        g_bridge_list_head = br->next;
+      else
+        prev_br->next = br->next;
+      sfree(br->name);
+      sfree(br);
+      break;
+    }
+  }
   return 0;
 }
 
@@ -319,59 +684,75 @@ static int ovs_stats_update_bridge(yajl_val bridge) {
   const char *new[] = {"new", NULL};
   const char *name[] = {"name", NULL};
   const char *ports[] = {"ports", NULL};
-  bridge_list_t *br = NULL;
-
-  if (bridge && YAJL_IS_OBJECT(bridge)) {
-    yajl_val row = yajl_tree_get(bridge, new, yajl_t_object);
-    if (row && YAJL_IS_OBJECT(row)) {
-      yajl_val br_name = yajl_tree_get(row, name, yajl_t_string);
-      yajl_val br_ports = yajl_tree_get(row, ports, yajl_t_array);
-      if (br_name && YAJL_IS_STRING(br_name)) {
-        br = ovs_stats_get_bridge(g_bridge_list_head, YAJL_GET_STRING(br_name));
-        pthread_mutex_lock(&g_stats_lock);
-        if (br == NULL) {
-          br = calloc(1, sizeof(*br));
-          if (!br) {
-            pthread_mutex_unlock(&g_stats_lock);
-            ERROR("%s: calloc(%zu) failed.", plugin_name, sizeof(*br));
-            return -1;
-          }
-          char *tmp = YAJL_GET_STRING(br_name);
 
-          if (tmp != NULL)
-            br->name = strdup(tmp);
-          if (br->name == NULL) {
-            sfree(br);
-            pthread_mutex_unlock(&g_stats_lock);
-            ERROR("%s: strdup failed.", plugin_name);
-            return -1;
-          }
-          br->next = g_bridge_list_head;
-          g_bridge_list_head = br;
-        }
-        pthread_mutex_unlock(&g_stats_lock);
-      }
-      if (br_ports && YAJL_IS_ARRAY(br_ports)) {
-        char *tmp = YAJL_GET_STRING(br_ports->u.array.values[0]);
-        if (tmp != NULL && strcmp("set", tmp) == 0) {
-          yajl_val *array = YAJL_GET_ARRAY(br_ports)->values;
-          size_t array_len = YAJL_GET_ARRAY(br_ports)->len;
-          if (array != NULL && array_len > 0 && YAJL_IS_ARRAY(array[1])) {
-            yajl_val *ports_arr = YAJL_GET_ARRAY(array[1])->values;
-            size_t ports_num = YAJL_GET_ARRAY(array[1])->len;
-            for (size_t i = 0; i < ports_num && ports_arr != NULL; i++)
-              ovs_stats_new_port(
-                  br, YAJL_GET_STRING(ports_arr[i]->u.array.values[1]));
-          }
-        } else
-          ovs_stats_new_port(br, YAJL_GET_STRING(br_ports->u.array.values[1]));
+  if (!bridge || !YAJL_IS_OBJECT(bridge))
+    goto failure;
+
+  yajl_val row = yajl_tree_get(bridge, new, yajl_t_object);
+  if (!row || !YAJL_IS_OBJECT(row))
+    return 0;
+
+  yajl_val br_name = yajl_tree_get(row, name, yajl_t_string);
+  if (!br_name || !YAJL_IS_STRING(br_name))
+    return 0;
+
+  if (!ovs_stats_is_monitored_bridge(YAJL_GET_STRING(br_name)))
+    return 0;
+
+  bridge_list_t *br =
+      ovs_stats_get_bridge(g_bridge_list_head, YAJL_GET_STRING(br_name));
+  if (br == NULL) {
+    br = calloc(1, sizeof(*br));
+    if (!br) {
+      ERROR("%s: calloc(%zu) failed.", plugin_name, sizeof(*br));
+      return -1;
+    }
+
+    char *tmp = YAJL_GET_STRING(br_name);
+    if (tmp != NULL)
+      br->name = strdup(tmp);
+
+    if (br->name == NULL) {
+      sfree(br);
+      ERROR("%s: strdup failed.", plugin_name);
+      return -1;
+    }
+
+    br->next = g_bridge_list_head;
+    g_bridge_list_head = br;
+  }
+
+  yajl_val br_ports = yajl_tree_get(row, ports, yajl_t_array);
+  if (!br_ports || !YAJL_IS_ARRAY(br_ports))
+    return 0;
+
+  char *tmp = YAJL_GET_STRING(br_ports->u.array.values[0]);
+  if (tmp != NULL && strcmp("set", tmp) == 0) {
+    yajl_val *array = YAJL_GET_ARRAY(br_ports)->values;
+    size_t array_len = YAJL_GET_ARRAY(br_ports)->len;
+    if (array != NULL && array_len > 0 && YAJL_IS_ARRAY(array[1])) {
+      if (YAJL_GET_ARRAY(array[1]) == NULL)
+        goto failure;
+
+      yajl_val *ports_arr = YAJL_GET_ARRAY(array[1])->values;
+      size_t ports_num = YAJL_GET_ARRAY(array[1])->len;
+      for (size_t i = 0; i < ports_num && ports_arr != NULL; i++) {
+        tmp = YAJL_GET_STRING(ports_arr[i]->u.array.values[1]);
+        if (tmp != NULL)
+          ovs_stats_new_port(br, tmp);
+        else
+          goto failure;
       }
     }
   } else {
-    ERROR("Incorrect JSON Bridge data");
-    return -1;
+    ovs_stats_new_port(br, YAJL_GET_STRING(br_ports->u.array.values[1]));
   }
+
   return 0;
+
+failure:
+  ERROR("Incorrect JSON Bridge data");
+  return -1;
 }
 
 /* Handle JSON with Bridge Table change event */
@@ -401,31 +782,32 @@ static void ovs_stats_bridge_table_change_cb(yajl_val jupdates) {
     }
    */
   const char *path[] = {"Bridge", NULL};
-
   yajl_val bridges = yajl_tree_get(jupdates, path, yajl_t_object);
 
-  if (bridges && YAJL_IS_OBJECT(bridges)) {
-    for (size_t i = 0; i < YAJL_GET_OBJECT(bridges)->len; i++) {
-      yajl_val bridge = YAJL_GET_OBJECT(bridges)->values[i];
-      ovs_stats_update_bridge(bridge);
-    }
+  if (!bridges || !YAJL_IS_OBJECT(bridges))
+    return;
+
+  pthread_mutex_lock(&g_stats_lock);
+  for (size_t i = 0; i < YAJL_GET_OBJECT(bridges)->len; i++) {
+    yajl_val bridge = YAJL_GET_OBJECT(bridges)->values[i];
+    ovs_stats_update_bridge(bridge);
   }
+  pthread_mutex_unlock(&g_stats_lock);
 }
 
 /* Handle Bridge Table delete event */
 static void ovs_stats_bridge_table_delete_cb(yajl_val jupdates) {
   const char *path[] = {"Bridge", NULL};
   yajl_val bridges = yajl_tree_get(jupdates, path, yajl_t_object);
-  yajl_val bridge;
-  if (bridges && YAJL_IS_OBJECT(bridges)) {
-    pthread_mutex_lock(&g_stats_lock);
-    for (size_t i = 0; i < YAJL_GET_OBJECT(bridges)->len; i++) {
-      bridge = YAJL_GET_OBJECT(bridges)->values[i];
-      ovs_stats_del_bridge(bridge);
-    }
-    pthread_mutex_unlock(&g_stats_lock);
+  if (!bridges || !YAJL_IS_OBJECT(bridges))
+    return;
+
+  pthread_mutex_lock(&g_stats_lock);
+  for (size_t i = 0; i < YAJL_GET_OBJECT(bridges)->len; i++) {
+    yajl_val bridge = YAJL_GET_OBJECT(bridges)->values[i];
+    ovs_stats_del_bridge(bridge);
   }
-  return;
+  pthread_mutex_unlock(&g_stats_lock);
 }
 
 /* Handle JSON with Bridge table initial values */
@@ -438,32 +820,62 @@ static void ovs_stats_bridge_table_result_cb(yajl_val jresult,
   return;
 }
 
-/* Update port name */
+/* Update port name and interface UUID(s)*/
 static int ovs_stats_update_port(const char *uuid, yajl_val port) {
   const char *new[] = {"new", NULL};
   const char *name[] = {"name", NULL};
-  yajl_val row;
-  port_list_t *portentry = NULL;
-  if (port && YAJL_IS_OBJECT(port)) {
-    row = yajl_tree_get(port, new, yajl_t_object);
-    if (row && YAJL_IS_OBJECT(row)) {
-      yajl_val port_name = yajl_tree_get(row, name, yajl_t_string);
-      if (port_name && YAJL_IS_STRING(port_name)) {
-        portentry = ovs_stats_get_port(uuid);
-        if (portentry == NULL)
-          portentry = ovs_stats_new_port(NULL, uuid);
-        if (portentry) {
-          pthread_mutex_lock(&g_stats_lock);
-          sstrncpy(portentry->name, YAJL_GET_STRING(port_name),
-                   sizeof(portentry->name));
-          pthread_mutex_unlock(&g_stats_lock);
-        }
-      }
-    }
-  } else {
+
+  if (!port || !YAJL_IS_OBJECT(port)) {
     ERROR("Incorrect JSON Port data");
     return -1;
   }
+
+  yajl_val row = yajl_tree_get(port, new, yajl_t_object);
+  if (!row || !YAJL_IS_OBJECT(row))
+    return 0;
+
+  yajl_val port_name = yajl_tree_get(row, name, yajl_t_string);
+  if (!port_name || !YAJL_IS_STRING(port_name))
+    return 0;
+
+  /* Create or get port by port uuid */
+  port_list_t *portentry = ovs_stats_new_port(NULL, uuid);
+  if (!portentry)
+    return 0;
+
+  sstrncpy(portentry->name, YAJL_GET_STRING(port_name),
+           sizeof(portentry->name));
+
+  yajl_val ifaces_root = ovs_utils_get_value_by_key(row, "interfaces");
+  char *ifaces_root_key =
+      YAJL_GET_STRING(YAJL_GET_ARRAY(ifaces_root)->values[0]);
+
+  if (strcmp("set", ifaces_root_key) == 0) {
+    // ifaces_root is ["set", [[ "uuid", "<some_uuid>" ], [ "uuid",
+    // "<another_uuid>" ], ... ]]
+    yajl_val ifaces_list = YAJL_GET_ARRAY(ifaces_root)->values[1];
+
+    // ifaces_list is [[ "uuid", "<some_uuid>" ], [ "uuid",
+    // "<another_uuid>" ], ... ]]
+    for (int i = 0; i < YAJL_GET_ARRAY(ifaces_list)->len; i++) {
+      yajl_val iface_tuple = YAJL_GET_ARRAY(ifaces_list)->values[i];
+
+      // iface_tuple is [ "uuid", "<some_uuid>" ]
+      char *iface_uuid_str =
+          YAJL_GET_STRING(YAJL_GET_ARRAY(iface_tuple)->values[1]);
+
+      // Also checks if interface already registered
+      ovs_stats_new_port_interface(portentry, iface_uuid_str);
+    }
+  } else {
+    // ifaces_root is [ "uuid", "<some_uuid>" ]
+    char *iface_uuid_str =
+        YAJL_GET_STRING(YAJL_GET_ARRAY(ifaces_root)->values[1]);
+
+    // Also checks if interface already registered
+    ovs_stats_new_port_interface(portentry, iface_uuid_str);
+  }
+
   return 0;
 }
 
@@ -477,6 +889,14 @@ static int ovs_stats_del_port(const char *uuid) {
         g_port_list_head = port->next;
       else
         prev_port->next = port->next;
+
+      for (interface_list_t *iface = port->iface; iface != NULL;
+           iface = port->iface) {
+        interface_list_t *del = iface;
+        port->iface = iface->next;
+        sfree(del);
+      }
+
       sfree(port);
       break;
     }
@@ -503,13 +923,15 @@ static void ovs_stats_port_table_change_cb(yajl_val jupdates) {
    */
   const char *path[] = {"Port", NULL};
   yajl_val ports = yajl_tree_get(jupdates, path, yajl_t_object);
-  yajl_val port;
-  if (ports && YAJL_IS_OBJECT(ports)) {
-    for (size_t i = 0; i < YAJL_GET_OBJECT(ports)->len; i++) {
-      port = YAJL_GET_OBJECT(ports)->values[i];
-      ovs_stats_update_port(YAJL_GET_OBJECT(ports)->keys[i], port);
-    }
+  if (!ports || !YAJL_IS_OBJECT(ports))
+    return;
+
+  pthread_mutex_lock(&g_stats_lock);
+  for (size_t i = 0; i < YAJL_GET_OBJECT(ports)->len; i++) {
+    yajl_val port = YAJL_GET_OBJECT(ports)->values[i];
+    ovs_stats_update_port(YAJL_GET_OBJECT(ports)->keys[i], port);
   }
+  pthread_mutex_unlock(&g_stats_lock);
   return;
 }
 
@@ -526,69 +948,75 @@ static void ovs_stats_port_table_result_cb(yajl_val jresult, yajl_val jerror) {
 static void ovs_stats_port_table_delete_cb(yajl_val jupdates) {
   const char *path[] = {"Port", NULL};
   yajl_val ports = yajl_tree_get(jupdates, path, yajl_t_object);
+  if (!ports || !YAJL_IS_OBJECT(ports))
+    return;
+
   pthread_mutex_lock(&g_stats_lock);
-  if (ports && YAJL_IS_OBJECT(ports))
-    for (size_t i = 0; i < YAJL_GET_OBJECT(ports)->len; i++) {
-      ovs_stats_del_port(YAJL_GET_OBJECT(ports)->keys[i]);
-    }
+  for (size_t i = 0; i < YAJL_GET_OBJECT(ports)->len; i++) {
+    ovs_stats_del_port(YAJL_GET_OBJECT(ports)->keys[i]);
+  }
   pthread_mutex_unlock(&g_stats_lock);
   return;
 }
 
 /* Update interface statistics */
-static int ovs_stats_update_iface_stats(port_list_t *port, yajl_val stats) {
-  yajl_val stat;
-  iface_counter counter_index = 0;
-  char *counter_name = NULL;
-  int64_t counter_value = 0;
-  if (stats && YAJL_IS_ARRAY(stats))
-    for (size_t i = 0; i < YAJL_GET_ARRAY(stats)->len; i++) {
-      stat = YAJL_GET_ARRAY(stats)->values[i];
-      if (!YAJL_IS_ARRAY(stat))
-        return -1;
-      counter_name = YAJL_GET_STRING(YAJL_GET_ARRAY(stat)->values[0]);
-      counter_index = ovs_stats_counter_name_to_type(counter_name);
-      counter_value = YAJL_GET_INTEGER(YAJL_GET_ARRAY(stat)->values[1]);
-      if (counter_index == not_supported)
-        continue;
-      port->stats[counter_index] = counter_value;
-    }
+static int ovs_stats_update_iface_stats(interface_list_t *iface,
+                                        yajl_val stats) {
+
+  if (!stats || !YAJL_IS_ARRAY(stats))
+    return 0;
+
+  for (size_t i = 0; i < YAJL_GET_ARRAY(stats)->len; i++) {
+    yajl_val stat = YAJL_GET_ARRAY(stats)->values[i];
+    if (!YAJL_IS_ARRAY(stat))
+      return -1;
+
+    char *counter_name = YAJL_GET_STRING(YAJL_GET_ARRAY(stat)->values[0]);
+    iface_counter counter_index = ovs_stats_counter_name_to_type(counter_name);
+    int64_t counter_value = YAJL_GET_INTEGER(YAJL_GET_ARRAY(stat)->values[1]);
+    if (counter_index == not_supported)
+      continue;
+
+    iface->stats[counter_index] = counter_value;
+  }
 
   return 0;
 }
 
 /* Update interface external_ids */
-static int ovs_stats_update_iface_ext_ids(port_list_t *port, yajl_val ext_ids) {
-  yajl_val ext_id;
-  char *key;
-  char *value;
-
-  if (ext_ids && YAJL_IS_ARRAY(ext_ids))
-    for (size_t i = 0; i < YAJL_GET_ARRAY(ext_ids)->len; i++) {
-      ext_id = YAJL_GET_ARRAY(ext_ids)->values[i];
-      if (!YAJL_IS_ARRAY(ext_id))
-        return -1;
-      key = YAJL_GET_STRING(YAJL_GET_ARRAY(ext_id)->values[0]);
-      value = YAJL_GET_STRING(YAJL_GET_ARRAY(ext_id)->values[1]);
-      if (key && value) {
-        if (strncmp(key, "iface-id", strlen(key)) == 0)
-          sstrncpy(port->ex_iface_id, value, sizeof(port->ex_iface_id));
-        else if (strncmp(key, "vm-uuid", strlen(key)) == 0)
-          sstrncpy(port->ex_vm_id, value, sizeof(port->ex_vm_id));
+static int ovs_stats_update_iface_ext_ids(interface_list_t *iface,
+                                          yajl_val ext_ids) {
+
+  if (!ext_ids || !YAJL_IS_ARRAY(ext_ids))
+    return 0;
+
+  for (size_t i = 0; i < YAJL_GET_ARRAY(ext_ids)->len; i++) {
+    yajl_val ext_id = YAJL_GET_ARRAY(ext_ids)->values[i];
+    if (!YAJL_IS_ARRAY(ext_id))
+      return -1;
+
+    char *key = YAJL_GET_STRING(YAJL_GET_ARRAY(ext_id)->values[0]);
+    char *value = YAJL_GET_STRING(YAJL_GET_ARRAY(ext_id)->values[1]);
+    if (key && value) {
+      if (strncmp(key, "iface-id", strlen(key)) == 0) {
+        sstrncpy(iface->ex_iface_id, value, sizeof(iface->ex_iface_id));
+      } else if (strncmp(key, "vm-uuid", strlen(key)) == 0) {
+        sstrncpy(iface->ex_vm_id, value, sizeof(iface->ex_vm_id));
       }
     }
+  }
 
   return 0;
 }
 
 /* Get interface statistic and external_ids */
-static int ovs_stats_update_iface(yajl_val iface) {
-  if (!iface || !YAJL_IS_OBJECT(iface)) {
-    ERROR("ovs_stats plugin: incorrect JSON port data");
+static int ovs_stats_update_iface(yajl_val iface_obj) {
+  if (!iface_obj || !YAJL_IS_OBJECT(iface_obj)) {
+    ERROR("ovs_stats plugin: incorrect JSON interface data");
     return -1;
   }
 
-  yajl_val row = ovs_utils_get_value_by_key(iface, "new");
+  yajl_val row = ovs_utils_get_value_by_key(iface_obj, "new");
   if (!row || !YAJL_IS_OBJECT(row))
     return 0;
 
@@ -596,13 +1024,26 @@ static int ovs_stats_update_iface(yajl_val iface) {
   if (!iface_name || !YAJL_IS_STRING(iface_name))
     return 0;
 
-  port_list_t *port = ovs_stats_get_port_by_name(YAJL_GET_STRING(iface_name));
-  if (port == NULL)
+  yajl_val iface_uuid = ovs_utils_get_value_by_key(row, "_uuid");
+  if (!iface_uuid || !YAJL_IS_ARRAY(iface_uuid) ||
+      YAJL_GET_ARRAY(iface_uuid)->len != 2)
+    return 0;
+
+  char *iface_uuid_str = YAJL_GET_STRING(YAJL_GET_ARRAY(iface_uuid)->values[1]);
+  if (iface_uuid_str == NULL) {
+    ERROR("ovs_stats plugin: incorrect JSON interface data");
+    return -1;
+  }
+
+  interface_list_t *iface = ovs_stats_get_interface(iface_uuid_str);
+  if (iface == NULL)
     return 0;
 
+  sstrncpy(iface->name, YAJL_GET_STRING(iface_name), sizeof(iface->name));
+
   yajl_val iface_stats = ovs_utils_get_value_by_key(row, "statistics");
   yajl_val iface_ext_ids = ovs_utils_get_value_by_key(row, "external_ids");
-  yajl_val iface_uuid = ovs_utils_get_value_by_key(row, "_uuid");
+
   /*
    * {
         "statistics": [
@@ -622,17 +1063,44 @@ static int ovs_stats_update_iface(yajl_val iface) {
       }
    Check that statistics is an array with 2 elements
    */
+
   if (iface_stats && YAJL_IS_ARRAY(iface_stats) &&
       YAJL_GET_ARRAY(iface_stats)->len == 2)
-    ovs_stats_update_iface_stats(port, YAJL_GET_ARRAY(iface_stats)->values[1]);
+    ovs_stats_update_iface_stats(iface, YAJL_GET_ARRAY(iface_stats)->values[1]);
+
   if (iface_ext_ids && YAJL_IS_ARRAY(iface_ext_ids))
-    ovs_stats_update_iface_ext_ids(port,
+    ovs_stats_update_iface_ext_ids(iface,
                                    YAJL_GET_ARRAY(iface_ext_ids)->values[1]);
-  if (iface_uuid && YAJL_IS_ARRAY(iface_uuid) &&
-      YAJL_GET_ARRAY(iface_uuid)->len == 2)
-    sstrncpy(port->iface_uuid,
-             YAJL_GET_STRING(YAJL_GET_ARRAY(iface_uuid)->values[1]),
-             sizeof(port->iface_uuid));
+
+  return 0;
+}
+
+/* Delete interface */
+static int ovs_stats_del_interface(const char *uuid) {
+  port_list_t *port = ovs_stats_get_port_by_interface_uuid(uuid);
+
+  if (port == NULL)
+    return 0;
+
+  interface_list_t *prev_iface = NULL;
+
+  for (interface_list_t *iface = port->iface; iface != NULL;
+       iface = port->iface) {
+    if (strncmp(iface->iface_uuid, uuid, strlen(iface->iface_uuid))) {
+
+      interface_list_t *del = iface;
+
+      if (prev_iface == NULL)
+        port->iface = iface->next;
+      else
+        prev_iface->next = iface->next;
+
+      sfree(del);
+      break;
+    } else {
+      prev_iface = iface;
+    }
+  }
 
   return 0;
 }
@@ -690,12 +1158,16 @@ static void ovs_stats_interface_table_change_cb(yajl_val jupdates) {
     }
    */
   const char *path[] = {"Interface", NULL};
-  yajl_val ports = yajl_tree_get(jupdates, path, yajl_t_object);
+  yajl_val interfaces = yajl_tree_get(jupdates, path, yajl_t_object);
+  if (!interfaces || !YAJL_IS_OBJECT(interfaces))
+    return;
+
   pthread_mutex_lock(&g_stats_lock);
-  if (ports && YAJL_IS_OBJECT(ports))
-    for (size_t i = 0; i < YAJL_GET_OBJECT(ports)->len; i++)
-      ovs_stats_update_iface(YAJL_GET_OBJECT(ports)->values[i]);
+  for (size_t i = 0; i < YAJL_GET_OBJECT(interfaces)->len; i++) {
+    ovs_stats_update_iface(YAJL_GET_OBJECT(interfaces)->values[i]);
+  }
   pthread_mutex_unlock(&g_stats_lock);
+
   return;
 }
 
@@ -709,6 +1181,22 @@ static void ovs_stats_interface_table_result_cb(yajl_val jresult,
   return;
 }
 
+/* Handle Interface Table delete event */
+static void ovs_stats_interface_table_delete_cb(yajl_val jupdates) {
+  const char *path[] = {"Interface", NULL};
+  yajl_val interfaces = yajl_tree_get(jupdates, path, yajl_t_object);
+  if (!interfaces || !YAJL_IS_OBJECT(interfaces))
+    return;
+
+  pthread_mutex_lock(&g_stats_lock);
+  for (size_t i = 0; i < YAJL_GET_OBJECT(interfaces)->len; i++) {
+    ovs_stats_del_interface(YAJL_GET_OBJECT(interfaces)->keys[i]);
+  }
+  pthread_mutex_unlock(&g_stats_lock);
+
+  return;
+}
+
 /* Setup OVS DB table callbacks  */
 static void ovs_stats_initialize(ovs_db_t *pdb) {
   const char *bridge_columns[] = {"name", "ports", NULL};
@@ -742,25 +1230,23 @@ static void ovs_stats_initialize(ovs_db_t *pdb) {
       ovs_stats_interface_table_result_cb,
       OVS_DB_TABLE_CB_FLAG_INITIAL | OVS_DB_TABLE_CB_FLAG_INSERT |
           OVS_DB_TABLE_CB_FLAG_MODIFY);
-}
-
-/* Check if bridge is configured to be monitored in config file */
-static int ovs_stats_is_monitored_bridge(const char *br_name) {
-  /* if no bridges are configured, return true */
-  if (g_monitored_bridge_list_head == NULL)
-    return 1;
-
-  /* check if given bridge exists */
-  if (ovs_stats_get_bridge(g_monitored_bridge_list_head, br_name) != NULL)
-    return 1;
 
-  return 0;
+  ovs_db_table_cb_register(pdb, "Interface", interface_columns,
+                           ovs_stats_interface_table_delete_cb, NULL,
+                           OVS_DB_TABLE_CB_FLAG_DELETE);
 }
 
 /* Delete all ports from port list */
 static void ovs_stats_free_port_list(port_list_t *head) {
   for (port_list_t *i = head; i != NULL;) {
     port_list_t *del = i;
+
+    for (interface_list_t *iface = i->iface; iface != NULL; iface = i->iface) {
+      interface_list_t *del2 = iface;
+      i->iface = iface->next;
+      sfree(del2);
+    }
+
     i = i->next;
     sfree(del);
   }
@@ -833,6 +1319,7 @@ static int ovs_stats_plugin_config(oconfig_item_t *ci) {
             char *br_name_dup = strdup(br_name);
             if (br_name_dup == NULL) {
               ERROR("%s: strdup() copy bridge name fail", plugin_name);
+              sfree(bridge);
               goto cleanup_fail;
             }
 
@@ -846,6 +1333,11 @@ static int ovs_stats_plugin_config(oconfig_item_t *ci) {
           }
         }
       }
+    } else if (strcasecmp("InterfaceStats", child->key) == 0) {
+      if (cf_util_get_boolean(child, &interface_stats) != 0) {
+        ERROR("%s: parse '%s' option failed", plugin_name, child->key);
+        return -1;
+      }
     } else {
       WARNING("%s: option '%s' not allowed here", plugin_name, child->key);
       goto cleanup_fail;
@@ -884,89 +1376,22 @@ static int ovs_stats_plugin_init(void) {
 
 /* OvS stats read callback. Read bridge/port information and submit it*/
 static int ovs_stats_plugin_read(__attribute__((unused)) user_data_t *ud) {
-  bridge_list_t *bridge;
-  port_list_t *port;
-  char devname[PORT_NAME_SIZE_MAX * 2];
-
   pthread_mutex_lock(&g_stats_lock);
-  for (bridge = g_bridge_list_head; bridge != NULL; bridge = bridge->next) {
-    if (ovs_stats_is_monitored_bridge(bridge->name)) {
-      for (port = g_port_list_head; port != NULL; port = port->next)
-        if (port->br == bridge) {
-          if (strlen(port->name) == 0)
-            /* Skip port w/o name. This is possible when read callback
-             * is called after Interface Table update callback but before
-             * Port table Update callback. Will add this port on next read */
-            continue;
-          meta_data_t *meta = meta_data_create();
-          if (meta != NULL) {
-            meta_data_add_string(meta, "uuid", port->iface_uuid);
-            if (strlen(port->ex_vm_id))
-              meta_data_add_string(meta, "vm-uuid", port->ex_vm_id);
-            if (strlen(port->ex_iface_id))
-              meta_data_add_string(meta, "iface-id", port->ex_iface_id);
-          }
-          snprintf(devname, sizeof(devname), "%s.%s", bridge->name, port->name);
-          ovs_stats_submit_one(devname, "if_collisions", NULL,
-                               port->stats[collisions], meta);
-          ovs_stats_submit_two(devname, "if_dropped", NULL,
-                               port->stats[rx_dropped], port->stats[tx_dropped],
-                               meta);
-          ovs_stats_submit_two(devname, "if_errors", NULL,
-                               port->stats[rx_errors], port->stats[tx_errors],
-                               meta);
-          ovs_stats_submit_two(devname, "if_packets", NULL,
-                               port->stats[rx_packets], port->stats[tx_packets],
-                               meta);
-          ovs_stats_submit_one(devname, "if_rx_errors", "crc",
-                               port->stats[rx_crc_err], meta);
-          ovs_stats_submit_one(devname, "if_rx_errors", "frame",
-                               port->stats[rx_frame_err], meta);
-          ovs_stats_submit_one(devname, "if_rx_errors", "over",
-                               port->stats[rx_over_err], meta);
-          ovs_stats_submit_one(devname, "if_rx_octets", NULL,
-                               port->stats[rx_bytes], meta);
-          ovs_stats_submit_one(devname, "if_tx_octets", NULL,
-                               port->stats[tx_bytes], meta);
-          ovs_stats_submit_two(devname, "if_packets", "1_to_64_packets",
-                               port->stats[rx_1_to_64_packets],
-                               port->stats[tx_1_to_64_packets], meta);
-          ovs_stats_submit_two(devname, "if_packets", "65_to_127_packets",
-                               port->stats[rx_65_to_127_packets],
-                               port->stats[tx_65_to_127_packets], meta);
-          ovs_stats_submit_two(devname, "if_packets", "128_to_255_packets",
-                               port->stats[rx_128_to_255_packets],
-                               port->stats[tx_128_to_255_packets], meta);
-          ovs_stats_submit_two(devname, "if_packets", "256_to_511_packets",
-                               port->stats[rx_256_to_511_packets],
-                               port->stats[tx_256_to_511_packets], meta);
-          ovs_stats_submit_two(devname, "if_packets", "512_to_1023_packets",
-                               port->stats[rx_512_to_1023_packets],
-                               port->stats[tx_512_to_1023_packets], meta);
-          ovs_stats_submit_two(devname, "if_packets", "1024_to_1518_packets",
-                               port->stats[rx_1024_to_1522_packets],
-                               port->stats[tx_1024_to_1522_packets], meta);
-          ovs_stats_submit_two(devname, "if_packets", "1523_to_max_packets",
-                               port->stats[rx_1523_to_max_packets],
-                               port->stats[tx_1523_to_max_packets], meta);
-          ovs_stats_submit_two(devname, "if_packets", "broadcast_packets",
-                               port->stats[rx_broadcast_packets],
-                               port->stats[tx_broadcast_packets], meta);
-          ovs_stats_submit_one(devname, "if_multicast", "tx_multicast_packets",
-                               port->stats[tx_multicast_packets], meta);
-          ovs_stats_submit_one(devname, "if_rx_errors", "rx_undersized_errors",
-                               port->stats[rx_undersized_errors], meta);
-          ovs_stats_submit_one(devname, "if_rx_errors", "rx_oversize_errors",
-                               port->stats[rx_oversize_errors], meta);
-          ovs_stats_submit_one(devname, "if_rx_errors", "rx_fragmented_errors",
-                               port->stats[rx_fragmented_errors], meta);
-          ovs_stats_submit_one(devname, "if_rx_errors", "rx_jabber_errors",
-                               port->stats[rx_jabber_errors], meta);
-
-          meta_data_destroy(meta);
-        }
-    } else
+  for (port_list_t *port = g_port_list_head; port != NULL; port = port->next) {
+    if (strlen(port->name) == 0)
+      /* Skip port w/o name. This is possible when read callback
+       * is called after Interface Table update callback but before
+       * Port table Update callback. Will add this port on next read */
       continue;
+
+    /* Skip port if it has no bridge */
+    if (!port->br)
+      continue;
+
+    ovs_stats_submit_port(port);
+
+    if (interface_stats)
+      ovs_stats_submit_interfaces(port);
   }
   pthread_mutex_unlock(&g_stats_lock);
   return 0;
-- 
2.19.2

